import re
from pathlib import Path

core = Path("ucc/src/ucc/core.py")
if not core.exists():
    raise SystemExit(f"core.py not found: {core}")

txt = core.read_text(encoding="utf-8")

m = re.search(r'(?m)^(?P<i>\s*)elif\s+stype\s*==\s*"emit_telemetry_snapshot"\s*:', txt)
if not m:
    raise SystemExit("Could not find emit_telemetry_snapshot branch to patch.")
indent = m.group("i")

# Replace from emit_telemetry_snapshot branch until the next elif stype== at same indent (or else/end)
pattern = r'(?ms)^' + re.escape(indent) + r'elif\s+stype\s*==\s*"emit_telemetry_snapshot"\s*:\s*.*?(?=^' + re.escape(indent) + r'elif\s+stype\s*==\s*"|^' + re.escape(indent) + r'else\s*:|\Z)'

L = []
a = L.append

a(f'{indent}elif stype == "emit_telemetry_snapshot":')
a(f'{indent}    # Canonical telemetry snapshot emitter (E from KONOMI CSV numeric substrings).')
a(f'{indent}    # IMPORTANT: Do NOT import json or Path in this function scope (avoid UnboundLocalError in other steps).')
a(f'{indent}    import hashlib as _hashlib')
a(f'{indent}    import sys as _sys')
a(f'{indent}    import platform as _platform')
a(f'{indent}    import math as _math')
a(f'{indent}    import re as _re')
a(f'{indent}    from datetime import datetime as _datetime, timezone as _timezone')
a(f'{indent}')
a(f'{indent}    params = step.get("params", {{}}) or {{}}')
a(f'{indent}    name_json = str(params.get("name_json", "telemetry_snapshot.json"))')
a(f'{indent}')
a(f'{indent}    src = context.get("input", {{}}) or {{}}')
a(f'{indent}    m = src.get("metrics", {{}}) or {{}}')
a(f'{indent}    fl = src.get("flags", {{}}) or {{}}')
a(f'{indent}    env = src.get("environment", {{}}) or {{}}')
a(f'{indent}')
a(f'{indent}    def _f(x, d):')
a(f'{indent}        try: return float(x)')
a(f'{indent}        except Exception: return float(d)')
a(f'{indent}')
a(f'{indent}    def _clamp01(x):')
a(f'{indent}        try: return max(0.0, min(1.0, float(x)))')
a(f'{indent}        except Exception: return 0.0')
a(f'{indent}')
a(f'{indent}    def _ratio(num, den, default=1.0):')
a(f'{indent}        try:')
a(f'{indent}            den = float(den)')
a(f'{indent}            if den <= 0: return float(default)')
a(f'{indent}            return float(num) / den')
a(f'{indent}        except Exception:')
a(f'{indent}            return float(default)')
a(f'{indent}')
a(f'{indent}    # T from coverage metrics')
a(f'{indent}    if "T" in m:')
a(f'{indent}        T = _f(m.get("T"), 1.0)')
a(f'{indent}    elif "T_required_sections_coverage" in m:')
a(f'{indent}        T = _f(m.get("T_required_sections_coverage"), 1.0)')
a(f'{indent}    elif "section_coverage" in m:')
a(f'{indent}        T = _f(m.get("section_coverage"), 1.0)')
a(f'{indent}    elif ("present_count" in m) and ("required_count" in m):')
a(f'{indent}        T = _ratio(m.get("present_count"), m.get("required_count"), default=1.0)')
a(f'{indent}    else:')
a(f'{indent}        T = 1.0')
a(f'{indent}    T = _clamp01(T)')
a(f'{indent}')
a(f'{indent}    # E from KONOMI result CSV numeric substrings (works even if values include units)')
a(f'{indent}    if "E" in m:')
a(f'{indent}        E = _f(m.get("E"), 1.0)')
a(f'{indent}    else:')
a(f'{indent}        perf_vals = []')
a(f'{indent}        inp_path = src.get("input_path")')
a(f'{indent}        if isinstance(inp_path, str) and inp_path:')
a(f'{indent}            p = Path(inp_path)')
a(f'{indent}            if (not p.exists()) and (not p.is_absolute()):')
a(f'{indent}                p = (Path.cwd() / p).resolve()')
a(f'{indent}            if p.exists():')
a(f'{indent}                base_dir = p.parent')
a(f'{indent}                csvs = [')
a(f'{indent}                    base_dir / "evgpu" / "evgpu_matmul_results.csv",')
a(f'{indent}                    base_dir / "femto" / "femto_async_results.csv",')
a(f'{indent}                    base_dir / "blockarray" / "blockarray_results.csv",')
a(f'{indent}                    base_dir / "cube" / "cube_results.csv",')
a(f'{indent}                ]')
a(f'{indent}                num_re = _re.compile(r"[-+]?\\d*\\.?\\d+(?:[eE][-+]?\\d+)?")')
a(f'{indent}                for fp in csvs:')
a(f'{indent}                    if fp.exists():')
a(f'{indent}                        try:')
a(f'{indent}                            txt2 = fp.read_text(encoding="utf-8-sig", errors="ignore")')
a(f'{indent}                            for s in num_re.findall(txt2):')
a(f'{indent}                                try: v = float(s)')
a(f'{indent}                                except Exception: continue')
a(f'{indent}                                if _math.isfinite(v): perf_vals.append(v)')
a(f'{indent}                        except Exception:')
a(f'{indent}                            pass')
a(f'{indent}')
a(f'{indent}        if perf_vals:')
a(f'{indent}            vals = []')
a(f'{indent}            for v in perf_vals[:5000]:')
a(f'{indent}                av = abs(v)')
a(f'{indent}                if av > 1000.0 and float(int(av)) == av:')
a(f'{indent}                    continue')
a(f'{indent}                vals.append(_math.log1p(av))')
a(f'{indent}            if not vals:')
a(f'{indent}                vals = [_math.log1p(abs(v)) for v in perf_vals[:5000]]')
a(f'{indent}            perf_index = sum(vals) / max(1, len(vals))')
a(f'{indent}            E = _math.exp(-perf_index / 30.0)')
a(f'{indent}        else:')
a(f'{indent}            E = T')
a(f'{indent}    E = _clamp01(E)')
a(f'{indent}')
a(f'{indent}    Psi = _clamp01(_f(m.get("Psi", E * T), E * T))')
a(f'{indent}    DeltaS = _f(m.get("DeltaS", 0.0), 0.0)')
a(f'{indent}    Lambda = _f(m.get("Lambda", 0.0), 0.0)')
a(f'{indent}')
a(f'{indent}    if "Es" in m:')
a(f'{indent}        Es = _clamp01(_f(m.get("Es"), 1.0))')
a(f'{indent}    else:')
a(f'{indent}        ok_flag = fl.get("sections_complete", fl.get("overall_pass", True))')
a(f'{indent}        Es = 1.0 if bool(ok_flag) else 0.0')
a(f'{indent}')
a(f'{indent}    telemetry_ok = bool(fl.get("overall_pass", fl.get("sections_complete", True)))')
a(f'{indent}')
a(f'{indent}    outdir.mkdir(parents=True, exist_ok=True)')
a(f'{indent}    out_path = outdir / name_json')
a(f'{indent}')
a(f'{indent}    pyver = env.get("python_version") or (_sys.version.replace("\\n", " "))')
a(f'{indent}    plat = env.get("platform") or _platform.platform()')
a(f'{indent}    gsha = env.get("git_commit") or ""')
a(f'{indent}')
a(f'{indent}    env_out = {{}}')
a(f'{indent}    env_out["python"] = str(pyver)')
a(f'{indent}    env_out["platform"] = str(plat)')
a(f'{indent}    env_out["git_commit"] = str(gsha)')
a(f'{indent}')
a(f'{indent}    metrics_out = {{}}')
a(f'{indent}    metrics_out["E"] = E')
a(f'{indent}    metrics_out["T"] = T')
a(f'{indent}    metrics_out["Psi"] = Psi')
a(f'{indent}    metrics_out["DeltaS"] = DeltaS')
a(f'{indent}    metrics_out["Lambda"] = Lambda')
a(f'{indent}    metrics_out["Es"] = Es')
a(f'{indent}')
a(f'{indent}    flags_out = {{}}')
a(f'{indent}    flags_out["telemetry_ok"] = telemetry_ok')
a(f'{indent}')
a(f'{indent}    telemetry = {{}}')
a(f'{indent}    telemetry["schema_id"] = "coherencelattice.telemetry_run.v1"')
a(f'{indent}    telemetry["version"] = 1')
a(f'{indent}    telemetry["run_id"] = outdir.name')
a(f'{indent}    telemetry["created_at"] = _datetime.now(_timezone.utc).isoformat()')
a(f'{indent}    telemetry["environment"] = env_out')
a(f'{indent}    telemetry["metrics"] = metrics_out')
a(f'{indent}    telemetry["flags"] = flags_out')
a(f'{indent}    telemetry["artifacts"] = []')
a(f'{indent}    telemetry["notes"] = "telemetry snapshot: T from coverage; E from KONOMI CSV numeric substrings"')
a(f'{indent}')
a(f'{indent}    out_path.write_text(json.dumps(telemetry, indent=2, sort_keys=True), encoding="utf-8")')
a(f'{indent}    h = _hashlib.sha256(out_path.read_bytes()).hexdigest()')
a(f'{indent}    telemetry["artifacts"] = [{{"path": out_path.name, "sha256": h}}]')
a(f'{indent}    out_path.write_text(json.dumps(telemetry, indent=2, sort_keys=True), encoding="utf-8")')
a(f'{indent}    context["output_files"].append(out_path)')
a(f'{indent}')

replacement = "\n".join(L) + "\n\n"
txt2 = re.sub(pattern, replacement, txt, count=1)
core.write_text(txt2, encoding="utf-8")
print("OK: emit_telemetry_snapshot patched (CSV numeric substrings)")
