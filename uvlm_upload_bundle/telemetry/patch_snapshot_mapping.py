import re
from pathlib import Path

core = Path("ucc/src/ucc/core.py")
txt = core.read_text(encoding="utf-8")

m = re.search(r'(?m)^(?P<i>\s*)elif\s+stype\s*==\s*"emit_report"\s*:', txt)
if not m:
    raise SystemExit("Could not find emit_report branch to anchor indentation.")

indent = m.group("i")

pattern = r'(?ms)^\s*elif\s+stype\s*==\s*"emit_telemetry_snapshot"\s*:\s*.*?(?=^\s*elif\s+stype\s*==\s*"emit_report"\s*:)'
if not re.search(pattern, txt):
    raise SystemExit("Could not find emit_telemetry_snapshot branch to replace.")

lines = [
    f'{indent}elif stype == "emit_telemetry_snapshot":',
    f'{indent}    # Canonical telemetry snapshot emitter (E from KONOMI CSV numeric leaves).',
    f'{indent}    # IMPORTANT: Do NOT import json or Path here (avoid UnboundLocalError in other steps).',
    f'{indent}    import hashlib as _hashlib',
    f'{indent}    import sys as _sys',
    f'{indent}    import platform as _platform',
    f'{indent}    import math as _math',
    f'{indent}    import csv as _csv',
    f'{indent}    from datetime import datetime as _datetime, timezone as _timezone',
    f'{indent}',
    f'{indent}    params = step.get("params", {{}}) or {{}}',
    f'{indent}    name_json = str(params.get("name_json", "telemetry_snapshot.json"))',
    f'{indent}',
    f'{indent}    src = context.get("input", {{}}) or {{}}  # expected: audit_bundle.json (ingested)',
    f'{indent}    m = src.get("metrics", {{}}) or {{}}',
    f'{indent}    fl = src.get("flags", {{}}) or {{}}',
    f'{indent}    env = src.get("environment", {{}}) or {{}}',
    f'{indent}',
    f'{indent}    def _f(x, d):',
    f'{indent}        try: return float(x)',
    f'{indent}        except Exception: return float(d)',
    f'{indent}',
    f'{indent}    def _clamp01(x):',
    f'{indent}        try: return max(0.0, min(1.0, float(x)))',
    f'{indent}        except Exception: return 0.0',
    f'{indent}',
    f'{indent}    def _ratio(num, den, default=1.0):',
    f'{indent}        try:',
    f'{indent}            den = float(den)',
    f'{indent}            if den <= 0: return float(default)',
    f'{indent}            return float(num) / den',
    f'{indent}        except Exception:',
    f'{indent}            return float(default)',
    f'{indent}',
    f'{indent}    # --- T (Transparency) from coverage metrics ---',
    f'{indent}    if "T" in m:',
    f'{indent}        T = _f(m.get("T"), 1.0)',
    f'{indent}    elif "T_required_sections_coverage" in m:',
    f'{indent}        T = _f(m.get("T_required_sections_coverage"), 1.0)',
    f'{indent}    elif "section_coverage" in m:',
    f'{indent}        T = _f(m.get("section_coverage"), 1.0)',
    f'{indent}    elif ("present_count" in m) and ("required_count" in m):',
    f'{indent}        T = _ratio(m.get("present_count"), m.get("required_count"), default=1.0)',
    f'{indent}    else:',
    f'{indent}        T = 1.0',
    f'{indent}    T = _clamp01(T)',
    f'{indent}',
    f'{indent}    # --- E (Empathy proxy) from KONOMI numeric performance leaves in CSV results ---',
    f'{indent}    if "E" in m:',
    f'{indent}        E = _f(m.get("E"), 1.0)',
    f'{indent}    elif "E_claim_coverage" in m:',
    f'{indent}        E = _f(m.get("E_claim_coverage"), 1.0)',
    f'{indent}    else:',
    f'{indent}        perf_vals = []',
    f'{indent}        inp_path = src.get("input_path")',
    f'{indent}        if isinstance(inp_path, str) and inp_path:',
    f'{indent}            p = Path(inp_path)',
    f'{indent}            if (not p.exists()) and (not p.is_absolute()):',
    f'{indent}                p = (Path.cwd() / p).resolve()',
    f'{indent}            if p.exists():',
    f'{indent}                base_dir = p.parent',
    f'{indent}                csvs = [',
    f'{indent}                    base_dir / "evgpu" / "evgpu_matmul_results.csv",',
    f'{indent}                    base_dir / "femto" / "femto_async_results.csv",',
    f'{indent}                    base_dir / "blockarray" / "blockarray_results.csv",',
    f'{indent}                    base_dir / "cube" / "cube_results.csv",',
    f'{indent}                ]',
    f'{indent}                for fp in csvs:',
    f'{indent}                    if fp.exists():',
    f'{indent}                        try:',
    f'{indent}                            with fp.open("r", encoding="utf-8-sig", newline="") as f:',
    f'{indent}                                rdr = _csv.reader(f)',
    f'{indent}                                for row in rdr:',
    f'{indent}                                    for cell in row:',
    f'{indent}                                        s = str(cell).strip()',
    f'{indent}                                        if not s: continue',
    f'{indent}                                        try:',
    f'{indent}                                            v = float(s)',
    f'{indent}                                        except Exception:',
    f'{indent}                                            continue',
    f'{indent}                                        if _math.isfinite(v):',
    f'{indent}                                            perf_vals.append(v)',
    f'{indent}                        except Exception:',
    f'{indent}                            pass',
    f'{indent}',
    f'{indent}        if perf_vals:',
    f'{indent}            # Use a damped index so E stays in a readable band, and small runtime variation shows up in ΔS/Λ.',
    f'{indent}            vals = [_math.log1p(abs(v)) for v in perf_vals[:2000]]',
    f'{indent}            perf_index = sum(vals) / max(1, len(vals))',
    f'{indent}            # Scale tuned to keep E roughly 0.7–0.95 depending on machine/results',
    f'{indent}            E = _math.exp(-perf_index / 30.0)',
    f'{indent}        else:',
    f'{indent}            E = T',
    f'{indent}    E = _clamp01(E)',
    f'{indent}',
    f'{indent}    Psi = _clamp01(_f(m.get("Psi", E * T), E * T))',
    f'{indent}    DeltaS = _f(m.get("DeltaS", 0.0), 0.0)',
    f'{indent}    Lambda = _f(m.get("Lambda", 0.0), 0.0)',
    f'{indent}',
    f'{indent}    # Es proxy',
    f'{indent}    if "Es" in m:',
    f'{indent}        Es = _clamp01(_f(m.get("Es"), 1.0))',
    f'{indent}    else:',
    f'{indent}        ok_flag = fl.get("sections_complete", fl.get("overall_pass", True))',
    f'{indent}        Es = 1.0 if bool(ok_flag) else 0.0',
    f'{indent}',
    f'{indent}    telemetry_ok = bool(fl.get("overall_pass", fl.get("sections_complete", True)))',
    f'{indent}',
    f'{indent}    outdir.mkdir(parents=True, exist_ok=True)',
    f'{indent}    out_path = outdir / name_json',
    f'{indent}',
    f'{indent}    pyver = env.get("python_version") or (_sys.version.replace("\\n", " "))',
    f'{indent}    plat = env.get("platform") or _platform.platform()',
    f'{indent}    gsha = env.get("git_commit") or ""',
    f'{indent}',
    f'{indent}    telemetry = {{',
    f'{indent}        "schema_id": "coherencelattice.telemetry_run.v1",',
    f'{indent}        "version": 1,',
    f'{indent}        "run_id": outdir.name,',
    f'{indent}        "created_at": _datetime.now(_timezone.utc).isoformat(),',
    f'{indent}        "environment": {{"python": str(pyver), "platform": str(plat), "git_commit": str(gsha)}},',
    f'{indent}        "metrics": {{"E": E, "T": T, "Psi": Psi, "DeltaS": DeltaS, "Lambda": Lambda, "Es": Es}},',
    f'{indent}        "flags": {{"telemetry_ok": telemetry_ok}},',
    f'{indent}        "artifacts": [],',
    f'{indent}        "notes": "telemetry snapshot: T from coverage; E from numeric CSV leaves in KONOMI results"',
    f'{indent}    }}',
    f'{indent}',
    f'{indent}    out_path.write_text(json.dumps(telemetry, indent=2, sort_keys=True), encoding="utf-8")',
    f'{indent}    h = _hashlib.sha256(out_path.read_bytes()).hexdigest()',
    f'{indent}    telemetry["artifacts"] = [{{"path": out_path.name, "sha256": h}}]',
    f'{indent}    out_path.write_text(json.dumps(telemetry, indent=2, sort_keys=True), encoding="utf-8")',
    f'{indent}    context["output_files"].append(out_path)',
    f'{indent}',
]

new_block = "\n".join(lines) + "\n\n"
txt2 = re.sub(pattern, new_block, txt, count=1)

core.write_text(txt2, encoding="utf-8")
print("OK: patched emit_telemetry_snapshot to compute E from KONOMI CSV numeric leaves")
